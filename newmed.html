<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js на Firebase</title>

  <!-- Importmap для загрузки three.js и аддонов -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
  <style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden; /* убирает скроллы */
    background: transparent; /* делает фон прозрачным */
    width: 100%;
    height: 100%;
  }

  canvas {
    display: block;
    background: transparent;
  }
</style>

<body>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 1);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    let model, mixer;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const targetObjects = [
      { name: "Mesh002", animationName: "Object03Action" },
      { name: "Mesh005", animationName: "Object01Action" },
    ];

    const interactiveObjects = [];

    new EXRLoader().load('https://raw.githubusercontent.com/letomaneteo/21/main/sunset_fairway_4k.exr', (texture) => {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = texture;
    });

    new GLTFLoader().load(
      'https://raw.githubusercontent.com/letomaneteo/myweb/main/Brain11.glb',
      (gltf) => {
        model = gltf.scene;
        mixer = new THREE.AnimationMixer(model);

        model.traverse((child) => {
          if (child.isMesh) {
            child.material.envMap = scene.environment;
            child.material.needsUpdate = true;

            const target = targetObjects.find(obj => obj.name === child.name);
            if (target) {
              const clip = gltf.animations.find(a => a.name === target.animationName);
              if (clip) {
                const action = mixer.clipAction(clip);
                action.clampWhenFinished = true;
                action.loop = THREE.LoopOnce;
                interactiveObjects.push({ mesh: child, action, playingForward: true });
              }
            }
          }
        });

        model.rotation.set(0, Math.PI / 2, 0);
        scene.add(model);
      },
      undefined,
      (err) => console.error('Model loading error:', err)
    );

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(interactiveObjects.map(obj => obj.mesh), true);
      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        interactiveObjects.forEach((obj) => {
          if (obj.mesh === clicked) {
            obj.action.reset();
            obj.action.timeScale = obj.playingForward ? 1 : -1;
            obj.action.time = obj.playingForward ? 0 : obj.action.getClip().duration;
            obj.action.play();
            obj.playingForward = !obj.playingForward;
          }
        });
      }
    }
    window.addEventListener('click', onClick);

    let isDragging = false;
    let prevMouse = { x: 0, y: 0 };
    let autoRotate = true;

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      autoRotate = false;
      prevMouse = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging && model) {
        const dx = e.clientX - prevMouse.x;
        const dy = e.clientY - prevMouse.y;
        model.rotation.y += dx * 0.005;
        model.rotation.x += dy * 0.005;
        prevMouse = { x: e.clientX, y: e.clientY };
      }
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isDragging = false;
      autoRotate = true;
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (model) {
        const scale = e.deltaY > 0 ? 0.95 : 1.05;
        model.scale.multiplyScalar(scale);
      }
    });

    let touchStart = { x: 0, y: 0 };
    let touchDistance = 0;

    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && model) {
        const cur = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        model.rotation.y += (cur.x - touchStart.x) * 0.005;
        model.rotation.x += (cur.y - touchStart.y) * 0.005;
        touchStart = cur;
        e.preventDefault();
      } else if (e.touches.length === 2 && model) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const scaleChange = dist / touchDistance;
        model.scale.multiplyScalar(scaleChange);
        touchDistance = dist;
        e.preventDefault();
      }
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      if (autoRotate && model) model.rotation.y += 0.001;
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
