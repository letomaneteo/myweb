<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Å—Ñ–µ—Ä–æ–π - Three.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
  // 1. –°–æ–∑–¥–∞—ë–º —Å—Ü–µ–Ω—É
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222); // –°–µ—Ä—ã–π —Ñ–æ–Ω

  // 2. –ö–∞–º–µ—Ä–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ —Å—Ü–µ–Ω—ã (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞)
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 0, 5); // –ö–∞–º–µ—Ä–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ

  // 3. –†–µ–Ω–¥–µ—Ä–µ—Ä
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // HDRI –§–æ–Ω (EXR)
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();

  new THREE.EXRLoader()
    .load('https://raw.githubusercontent.com/letomaneteo/21/main/lonely_road_afternoon_puresky_2k.exr', function (texture) {
      const hdrTexture = pmremGenerator.fromEquirectangular(texture).texture;
      scene.environment = hdrTexture; // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ
      scene.background = hdrTexture;  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω
    });

  // 4. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π (—Ç–æ–ª—å–∫–æ –≤—Ä–∞—â–µ–Ω–∏–µ)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enablePan = false; // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
  controls.enableZoom = false; // –û—Ç–∫–ª—é—á–∞–µ–º –∑—É–º
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.rotateSpeed = 1.0;
  // (–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∞–Ω–∏–π, –æ—Ç–≤–µ—á–∞–≤—à–∞—è –∑–∞ —Å–≤–∞–π–ø—ã, –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞)

  // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–µ–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –±–æ–ª—å—à–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
  const video = document.createElement('video');
  video.src = 'https://raw.githubusercontent.com/letomaneteo/21/main/BigPlane.mp4';
  video.loop = true;
  video.muted = true;
  video.playsInline = true;
  video.crossOrigin = "anonymous"; 
  document.body.appendChild(video);

  const videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;

  const planeGeometry = new THREE.PlaneGeometry(10, 5);
  const planeMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
  const videoPlane = new THREE.Mesh(planeGeometry, planeMaterial);
  videoPlane.position.set(60, 40, 0);
  videoPlane.rotation.y = -Math.PI / 2;
  scene.add(videoPlane);

  // –ó–∞–ø—É—Å–∫–∞–µ–º –≤–∏–¥–µ–æ –±–µ–∑ –∑–≤—É–∫–∞ –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã
  controls.addEventListener('change', () => {
    if (video.paused) {
      video.play().then(() => {
        console.log('üé¨ –í–∏–¥–µ–æ –∑–∞–ø—É—â–µ–Ω–æ –±–µ–∑ –∑–≤—É–∫–∞ –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏.');
      }).catch(err => console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤–∏–¥–µ–æ:', err));
    }
  });

  // –í–∫–ª—é—á–∞–µ–º –∑–≤—É–∫ –ø—Ä–∏ –∫–ª–∏–∫–µ
  let soundEnabled = false;
  window.addEventListener('click', () => {
    if (!soundEnabled) {
      video.muted = false;
      video.play().then(() => {
        console.log('üîä –ó–≤—É–∫ –≤–∫–ª—é—á–µ–Ω –ø—Ä–∏ –∫–ª–∏–∫–µ!');
        soundEnabled = true;
      }).catch(err => console.error('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫:', err));
    }
  });

  const videos = [
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/Plane1.mp4", link: "https://app.leonardo.ai/" },
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/Plane1.mp4", link: "https://app.leonardo.ai/" },
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/oblaka.mp4", link: "https://app.leonardo.ai/" }
  ];

  // –°–æ–∑–¥–∞—ë–º HTML-–≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã
  const videoElements = videos.map(videoData => {
    const video = document.createElement('video');
    video.src = videoData.url;
    video.crossOrigin = "anonymous";
    video.loop = true;
    video.muted = true;
    video.play();
    return { element: video, link: videoData.link };
  });

  // –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞—ë–º —Ç–µ–∫—Å—Ç—É—Ä—ã
  const videoTextures = videoElements.map(videoObj => {
    const texture = new THREE.VideoTexture(videoObj.element);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.format = THREE.RGBAFormat;
    return { texture, link: videoObj.link };
  });

  // 5. –°–æ–∑–¥–∞—ë–º –º–∞—Å—Å–∏–≤ –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π
  const planes = [];
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let currentTarget = null; // –¢–µ–∫—É—â–∞—è –≤—ã–±—Ä–∞–Ω–Ω–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å
  let previousCameraPosition = new THREE.Vector3(0, 0, 0); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã

  function createLink(url) {
    const link = document.createElement("a");
    link.href = url;
    link.target = "_blank";
    link.textContent = "–í–æ–π—Ç–∏";
    link.style.position = "absolute";
    link.style.display = "none";
    link.style.color = "white";
    link.style.background = "rgba(0, 0, 0, 0.8)";
    link.style.padding = "5px 10px";
    link.style.borderRadius = "5px";
    link.style.textDecoration = "none";
    link.style.zIndex = 1000;
    document.body.appendChild(link);

    link.addEventListener('click', (event) => {
      event.stopPropagation();
    });

    return link;
  }

  function updateLinkPositions() {
    planes.forEach((plane) => {
      const link = plane.userData.link;
      if (!link) return;

      const distance = camera.position.distanceTo(plane.position);
      if (distance < 3) {
        const vector = plane.position.clone().project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        link.style.left = `${x}px`;
        link.style.top = `${y + 180}px`;
        link.style.display = "block";
      } else {
        link.style.display = "none";
      }
    });
  }

  // 6. –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–æ—Å–∫–æ—Å—Ç–∏, —Å–º–æ—Ç—Ä—è—â–µ–π –Ω–∞ —Ü–µ–Ω—Ç—Ä
  function createPlane(videoObj, position) {
    const geometry = new THREE.PlaneGeometry(2, 3);
    const videoTexture = videoObj.texture;
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    videoTexture.format = THREE.RGBAFormat;

    const material = new THREE.MeshBasicMaterial({
      map: videoTexture,
      side: THREE.DoubleSide,
      transparent: true,
      alphaTest: 0.1
    });

    const plane = new THREE.Mesh(geometry, material);
    plane.position.set(position.x, position.y, position.z);
    plane.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(plane);
    planes.push(plane);

    const link = createLink(videoObj.link);
    plane.userData.link = link;

    return plane;
  }

  // 7. –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –Ω–∞ —Å—Ñ–µ—Ä–µ (Fibonacci Sphere)
  function fibonacciSphere(samples, radius) {
    let points = [];
    const phi = Math.PI * (3 - Math.sqrt(5));
    for (let i = 0; i < samples; i++) {
      let y = 1 - (i / (samples - 1)) * 2;
      if (Math.abs(y) > 0.9) continue;
      let r = Math.sqrt(1 - y * y);
      let theta = phi * i;
      let x = Math.cos(theta) * r;
      let z = Math.sin(theta) * r;
      points.push(new THREE.Vector3(x * radius, y * radius, z * radius));
    }
    return points;
  }

  // 8. –°–æ–∑–¥–∞—ë–º 50 –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –Ω–∞ —Å—Ñ–µ—Ä–µ
  const totalPlanes = 50;
  const radius = 10;
  const positions = fibonacciSphere(totalPlanes, radius);
  positions.forEach((pos, i) => {
    const videoObj = videoTextures[i % videoTextures.length];
    createPlane(videoObj, pos);
  });

  // 9. –§—É–Ω–∫—Ü–∏—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã –∫ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
  function moveToPlane(target) {
    if (currentTarget === target) return;
    currentTarget = target;
    controls.enableRotate = false;
    const targetDirection = new THREE.Vector3().copy(target.position).normalize();
    const targetPosition = targetDirection.multiplyScalar(radius * 0.75);
    let progress = 0;
    function animateMove() {
      if (progress < 1) {
        progress += 0.02;
        camera.position.lerp(targetPosition, progress);
        controls.target.lerp(target.position, progress);
        requestAnimationFrame(animateMove);
      }
    }
    animateMove();
  }

  // 10. –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫–∞–º–µ—Ä—ã –≤ —Ü–µ–Ω—Ç—Ä —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —É–≥–ª–∞
  function resetCamera() {
    if (!currentTarget) return;
    currentTarget = null;
    controls.enableRotate = true;
    let startPos = camera.position.clone();
    let direction = startPos.clone().sub(controls.target).normalize();
    let targetPos = direction.multiplyScalar(radius);
    let progress = 0;
    function animateReset() {
      if (progress < 1) {
        progress += 0.02;
        camera.position.lerpVectors(startPos, targetPos, progress);
        requestAnimationFrame(animateReset);
      } else {
        controls.target.set(0, 0, 0);
      }
    }
    animateReset();
  }

  // 11. –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —Å—Ü–µ–Ω–µ (—Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –Ω–∞ –ü–ö –∏ –º–æ–±–∏–ª—å–Ω—ã—Ö)
  let lastClickedPlane = null;
  let clickCount = 0;
  let clickTimer = null;

  function onDocumentClick(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planes);
    if (intersects.length > 0) {
      const clickedPlane = intersects[0].object;
      if (clickedPlane === lastClickedPlane) {
        clickCount++;
      } else {
        clickCount = 1;
        lastClickedPlane = clickedPlane;
      }
      if (clickCount === 2) {
        resetCamera();
        clickCount = 0;
        lastClickedPlane = null;
      } else {
        previousCameraPosition.copy(camera.position);
        moveToPlane(clickedPlane);
      }
      clearTimeout(clickTimer);
      clickTimer = setTimeout(() => {
        clickCount = 0;
        lastClickedPlane = null;
      }, 400);
    }
  }

  window.addEventListener('click', onDocumentClick, false);
  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ touchstart –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—ë–Ω

  // 14. –ê–Ω–∏–º–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    updateLinkPositions();
    renderer.render(scene, camera);
  }
  animate();

  // 15. –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å —ç–∫—Ä–∞–Ω–∞
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
