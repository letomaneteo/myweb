<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–∞–≤–Ω–æ–º–µ—Ä–Ω—ã–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Å—Ñ–µ—Ä–æ–π - Three.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>

    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
    // 1. –°–æ–∑–¥–∞—ë–º —Å—Ü–µ–Ω—É
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222); // –°–µ—Ä—ã–π —Ñ–æ–Ω

    // 2. –ö–∞–º–µ—Ä–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ —Å—Ü–µ–Ω—ã (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞)
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5); // –ö–∞–º–µ—Ä–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ

    // 3. –†–µ–Ω–¥–µ—Ä–µ—Ä
    const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);


    // HDRI –§–æ–Ω (EXR)
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    new THREE.EXRLoader()
        .load('https://raw.githubusercontent.com/letomaneteo/21/main/lonely_road_afternoon_puresky_2k.exr', function (texture) {
            const hdrTexture = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = hdrTexture; // –î–æ–±–∞–≤–ª—è–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ
            scene.background = hdrTexture; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω
        });


    // 4. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π (—Ç–æ–ª—å–∫–æ –≤—Ä–∞—â–µ–Ω–∏–µ)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enablePan = false; // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
controls.enableZoom = false; // –û—Ç–∫–ª—é—á–∞–µ–º –∑—É–º
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 1.0;
controls.touches = {
    ONE: THREE.TOUCH.ROTATE, // –û–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ
    TWO: THREE.TOUCH.NONE     // –û—Ç–∫–ª—é—á–∞–µ–º –∑—É–º —á–µ—Ä–µ–∑ –¥–≤–∞ –ø–∞–ª—å—Ü–∞
};

if (/Mobi|Android/i.test(navigator.userAgent)) {
    // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ —Ç–∞–ø–∞ –¥–ª—è –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è
    renderer.domElement.addEventListener('touchstart', function (event) {
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            // –õ–æ–≥–∏–∫–∞ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è –∫ –ø–ª–æ—Å–∫–æ—Å—Ç–∏, –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞—è –∫–ª–∏–∫—É –Ω–∞ –ü–ö
            raycastAndZoom(touch.clientX, touch.clientY);
        }
    }, { passive: false });

    // –û—Ç–∫–ª—é—á–∞–µ–º –∂–µ—Å—Ç—ã –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
    renderer.domElement.addEventListener('gesturestart', function (event) {
        event.preventDefault();
    }, { passive: false });
}

// –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–µ–æ –∫–∞–∫ —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –±–æ–ª—å—à–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
// –°–æ–∑–¥–∞–µ–º –≤–∏–¥–µ–æ-—ç–ª–µ–º–µ–Ω—Ç
const video = document.createElement('video');
video.src = 'https://raw.githubusercontent.com/letomaneteo/21/main/BigPlane.mp4';
video.loop = true;
video.muted = true; // –ó–∞–ø—É—Å–∫–∞–µ–º –±–µ–∑ –∑–≤—É–∫–∞
video.playsInline = true;
video.crossOrigin = "anonymous"; 
document.body.appendChild(video); 

// –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –≤–∏–¥–µ–æ
const videoTexture = new THREE.VideoTexture(video);
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.format = THREE.RGBAFormat;

// –°–æ–∑–¥–∞–µ–º –ø–ª–æ—Å–∫–æ—Å—Ç—å —Å –≤–∏–¥–µ–æ
const planeGeometry = new THREE.PlaneGeometry(50, 28);
const planeMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
const videoPlane = new THREE.Mesh(planeGeometry, planeMaterial);
videoPlane.position.set(60, 40, 0);
videoPlane.lookAt(new THREE.Vector3(0, 0, 0)); // –ü–ª–æ—Å–∫–æ—Å—Ç—å —Å–º–æ—Ç—Ä–∏—Ç –≤ —Ü–µ–Ω—Ç—Ä
scene.add(videoPlane);

// –ó–∞–ø—É—Å–∫–∞–µ–º –≤–∏–¥–µ–æ –±–µ–∑ –∑–≤—É–∫–∞ –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã
controls.addEventListener('change', () => {
    if (video.paused) {
        video.play().then(() => {
            console.log('üé¨ –í–∏–¥–µ–æ –∑–∞–ø—É—â–µ–Ω–æ –±–µ–∑ –∑–≤—É–∫–∞ –ø—Ä–∏ –≤—Ä–∞—â–µ–Ω–∏–∏.');
        }).catch(err => console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤–∏–¥–µ–æ:', err));
    }
});

// –í–∫–ª—é—á–∞–µ–º –∑–≤—É–∫ –ø—Ä–∏ –∫–ª–∏–∫–µ
let soundEnabled = false;
window.addEventListener('click', () => {
    if (!soundEnabled) {
        video.muted = false;
        video.play().then(() => {
            console.log('üîä –ó–≤—É–∫ –≤–∫–ª—é—á–µ–Ω –ø—Ä–∏ –∫–ª–∏–∫–µ!');
            soundEnabled = true;
        }).catch(err => console.error('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫:', err));
    }
});




const videos = [
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/Plane1.mp4", link: "https://app.leonardo.ai/" },
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/Plane1.mp4", link: "https://app.leonardo.ai/" },
    { url: "https://raw.githubusercontent.com/letomaneteo/21/main/oblaka.mp4", link: "https://app.leonardo.ai/" }
];

// –°–æ–∑–¥–∞—ë–º HTML-–≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã
const videoElements = videos.map(videoData => {
    const video = document.createElement('video');
    video.src = videoData.url;
    video.crossOrigin = "anonymous";
    video.loop = true;
    video.muted = true;
    video.play(); // –ó–∞–ø—É—Å–∫–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
    return { element: video, link: videoData.link };
});

// –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞—ë–º —Ç–µ–∫—Å—Ç—É—Ä—ã
const videoTextures = videoElements.map(videoObj => {
    const texture = new THREE.VideoTexture(videoObj.element);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.format = THREE.RGBAFormat;
    return { texture, link: videoObj.link };
});




    // 5. –°–æ–∑–¥–∞—ë–º –º–∞—Å—Å–∏–≤ –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π
    const planes = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let currentTarget = null; // –¢–µ–∫—É—â–∞—è –≤—ã–±—Ä–∞–Ω–Ω–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å
    let previousCameraPosition = new THREE.Vector3(0, 0, 0); // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã

function createLink(url) {
    const link = document.createElement("a");
    link.href = url; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Å—ã–ª–∫—É
    link.target = "_blank";  // –°—Å—ã–ª–∫–∞ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è –≤ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ
    link.textContent = "–í–æ–π—Ç–∏"; // –¢–µ–∫—Å—Ç —Å—Å—ã–ª–∫–∏
    link.style.position = "absolute";
    link.style.display = "none";  // –°–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    link.style.color = "white";
    link.style.background = "rgba(0, 0, 0, 0.8)";
    link.style.padding = "5px 10px";
    link.style.borderRadius = "5px";
    link.style.textDecoration = "none";
    link.style.zIndex = 1000; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Å–æ–∫–∏–π z-–∏–Ω–¥–µ–∫—Å
    document.body.appendChild(link);

    link.addEventListener('click', (event) => {
        event.stopPropagation(); // –ü—Ä–µ–∫—Ä–∞—â–∞–µ–º –≤—Å–ø–ª—ã—Ç–∏–µ —Å–æ–±—ã—Ç–∏—è, —á—Ç–æ–±—ã –æ–Ω–æ –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–ª–æ—Å—å Three.js
    });

    return link;
}


function updateLinkPositions() {
    planes.forEach((plane) => {
        const link = plane.userData.link;
        if (!link) return;

        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–∞–º–µ—Ä—ã –¥–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
        const distance = camera.position.distanceTo(plane.position);
        
        if (distance < 3) { // –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ –±–ª–∏–∑–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É
            const vector = plane.position.clone().project(camera); // –ü—Ä–æ–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≤ 2D
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth; // –ü–µ—Ä–µ–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø–∏–∫—Å–µ–ª–∏ –ø–æ –æ—Å–∏ X
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight; // –ü–µ—Ä–µ–≤–æ–¥–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø–∏–∫—Å–µ–ª–∏ –ø–æ –æ—Å–∏ Y

            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –≤ 2D-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
            link.style.left = `${x}px`;
            link.style.top = `${y+180}px`;
            link.style.display = "block"; // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É
        } else {
            link.style.display = "none"; // –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ –¥–∞–ª–µ–∫–æ - —Å–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É
        }
    });
}


    // 6. –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–æ—Å–∫–æ—Å—Ç–∏, —Å–º–æ—Ç—Ä—è—â–µ–π –Ω–∞ —Ü–µ–Ω—Ç—Ä
    function createPlane(videoObj, position) {
    const geometry = new THREE.PlaneGeometry(2, 3);
    const videoTexture = videoObj.texture;
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    videoTexture.format = THREE.RGBAFormat;

    const material = new THREE.MeshBasicMaterial({
    map: videoTexture,
    side: THREE.DoubleSide,
    transparent: true,        // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
    alphaTest: 0.1            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ä–æ–≥ –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π
});

    const plane = new THREE.Mesh(geometry, material);
    plane.position.set(position.x, position.y, position.z);
    plane.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(plane);
    planes.push(plane);

    // –°–æ–∑–¥–∞—ë–º –∏ –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –∫ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
    const link = createLink(videoObj.link);
    plane.userData.link = link;

    return plane;
}



    // 7. –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –Ω–∞ —Å—Ñ–µ—Ä–µ (Fibonacci Sphere)
    function fibonacciSphere(samples, radius) {
    let points = [];
    const phi = Math.PI * (3 - Math.sqrt(5)); // –ó–æ–ª–æ—Ç–æ–µ —Å–µ—á–µ–Ω–∏–µ

    for (let i = 0; i < samples; i++) {
        let y = 1 - (i / (samples - 1)) * 2; // y –æ—Ç -1 –¥–æ 1

        if (Math.abs(y) > 0.9) continue; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–æ—á–∫–∏ –±–ª–∏–∂–µ –∫ –ø–æ–ª—é—Å–∞–º

        let r = Math.sqrt(1 - y * y); // –†–∞–¥–∏—É—Å –∫—Ä—É–≥–∞ –Ω–∞ –¥–∞–Ω–Ω–æ–π –≤—ã—Å–æ—Ç–µ
        let theta = phi * i; // –£–≥–æ–ª –ø–æ –∑–æ–ª–æ—Ç–æ–º—É —Å–µ—á–µ–Ω–∏—é
        let x = Math.cos(theta) * r;
        let z = Math.sin(theta) * r;

        points.push(new THREE.Vector3(x * radius, y * radius, z * radius));
    }

    return points;
}

    // 8. –°–æ–∑–¥–∞—ë–º 50 –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –Ω–∞ —Å—Ñ–µ—Ä–µ
    const totalPlanes = 50;
    const radius = 10;
    const positions = fibonacciSphere(totalPlanes, radius);

  
  positions.forEach((pos, i) => {
    const videoObj = videoTextures[i % videoTextures.length]; // –ë–µ—Ä–µ–º —É–∂–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
    createPlane(videoObj, pos);
});




    // 9. –§—É–Ω–∫—Ü–∏—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã –∫ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
    function moveToPlane(target) {
        if (currentTarget === target) return; // –ï—Å–ª–∏ —É–∂–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω—ã - –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        currentTarget = target;

        // –û—Ç–∫–ª—é—á–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
        controls.enableRotate = false;

        const targetDirection = new THREE.Vector3().copy(target.position).normalize();
        const targetPosition = targetDirection.multiplyScalar(radius * 0.75); // –ß—É—Ç—å –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É

        let progress = 0;
        function animateMove() {
            if (progress < 1) {
                progress += 0.02;
                camera.position.lerp(targetPosition, progress);
                controls.target.lerp(target.position, progress);
                requestAnimationFrame(animateMove);
            }
        }
        animateMove();
    }

    // 10. –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫–∞–º–µ—Ä—ã –≤ —Ü–µ–Ω—Ç—Ä —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —É–≥–ª–∞
    function resetCamera() {
    if (!currentTarget) return;
    currentTarget = null;

    controls.enableRotate = true;

    let startPos = camera.position.clone();
    let direction = startPos.clone().sub(controls.target).normalize(); // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
    let targetPos = direction.multiplyScalar(radius); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º
    
    let progress = 0;

    function animateReset() {
        if (progress < 1) {
            progress += 0.02;
            camera.position.lerpVectors(startPos, targetPos, progress);
            requestAnimationFrame(animateReset);
        } else {
            controls.target.set(0, 0, 0); // –¶–µ–Ω—Ç—Ä —Å—Ü–µ–Ω—ã, –Ω–æ —É–≥–æ–ª –∫–∞–º–µ—Ä—ã —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è
        }
    }
    animateReset();
}





    // 11. –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —Å—Ü–µ–Ω–µ
    let lastClickedPlane = null;
let clickCount = 0;
let clickTimer = null;

function onDocumentClick(event) {
    event.preventDefault();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planes);

    if (intersects.length > 0) {
        const clickedPlane = intersects[0].object;

        if (clickedPlane === lastClickedPlane) {
            clickCount++;
        } else {
            clickCount = 1;
            lastClickedPlane = clickedPlane;
        }

        if (clickCount === 2) {
            resetCamera(); // –í—ã–∑—ã–≤–∞–µ–º resetCamera() –ø—Ä–∏ –¥–≤–æ–π–Ω–æ–º –∫–ª–∏–∫–µ
            clickCount = 0;
            lastClickedPlane = null;
        } else {
            previousCameraPosition.copy(camera.position);
            moveToPlane(clickedPlane);
        }

        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => {
            clickCount = 0;
            lastClickedPlane = null;
        }, 400); // –£–º–µ–Ω—å—à–∏–ª —Ç–∞–π–º–µ—Ä –¥–ª—è –±–æ–ª–µ–µ —É–¥–æ–±–Ω–æ–≥–æ –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞
    }
}



    // 12. –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∞–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
   let lastTouchTime = 0;
let lastTouchedPlane = null;

function onDocumentTouch(event) {
    event.preventDefault();

    const touch = event.touches[0];
    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planes);

    if (intersects.length > 0) {
        const touchedPlane = intersects[0].object;
        const now = Date.now();

        if (touchedPlane === lastTouchedPlane && now - lastTouchTime < 400) {
            resetCamera(); // –î–≤–æ–π–Ω–æ–π —Ç–∞–ø –ø–æ —Ç–æ–π –∂–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–º–µ—Ä—É
            lastTouchedPlane = null;
        } else {
            lastTouchedPlane = touchedPlane;
            lastTouchTime = now;
            moveToPlane(touchedPlane);
        }
    }
}


    window.addEventListener('click', onDocumentClick, false);
    window.addEventListener('touchstart', onDocumentTouch, false);

    // 13. –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–∞—â–µ–Ω–∏—è –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
    if ('ontouchstart' in window) {
        controls.rotateSpeed = -1.0; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ
    }

    // 14. –ê–Ω–∏–º–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
    function animate() {
    requestAnimationFrame(animate);
    controls.update();
    updateLinkPositions(); // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ —Å—Å—ã–ª–æ–∫
    renderer.render(scene, camera);
}

    animate();

    // 15. –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å —ç–∫—Ä–∞–Ω–∞
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>

</body>
</html>
