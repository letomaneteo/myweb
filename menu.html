<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Равномерные плоскости сферой - Three.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 10);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.enableDamping = true;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let currentTarget = null;
    let previousCameraPosition = new THREE.Vector3();
    const planes = [];

    function createPlane(textureUrl, position) {
        const geometry = new THREE.PlaneGeometry(3, 2);
        const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.copy(position);
        plane.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add(plane);
        planes.push(plane);
        new THREE.TextureLoader().load(textureUrl, (texture) => {
            material.map = texture;
            material.transparent = true;
            material.alphaTest = 0.5;
            material.needsUpdate = true;
        });
        return plane;
    }

    function fibonacciSphere(samples, radius) {
        let points = [];
        const phi = Math.PI * (3 - Math.sqrt(5));
        for (let i = 0; i < samples; i++) {
            let y = 1 - (i / (samples - 1)) * 2;
            let r = Math.sqrt(1 - y * y);
            let theta = phi * i;
            let x = Math.cos(theta) * r;
            let z = Math.sin(theta) * r;
            points.push(new THREE.Vector3(x * radius, y * radius, z * radius));
        }
        return points;
    }

    const totalPlanes = 50;
    const radius = 10;
    const positions = fibonacciSphere(totalPlanes, radius);
    const textures = [
        'https://i.imgur.com/XdFK6x3.png',
        'https://i.imgur.com/7RmDFNW.png',
        'https://i.imgur.com/8Hg0fls.png',
    ];
    positions.forEach((pos, i) => createPlane(textures[i % textures.length], pos));

    function moveToPlane(target) {
        if (currentTarget === target) return;
        currentTarget = target;
        controls.enableRotate = false;
        previousCameraPosition.copy(camera.position);
        const targetDirection = target.position.clone().normalize();
        const targetPosition = targetDirection.multiplyScalar(radius * 0.85);
        let progress = 0;
        function animateMove() {
            if (progress < 1) {
                progress += 0.02;
                camera.position.lerp(targetPosition, progress);
                controls.target.lerp(target.position, progress);
                requestAnimationFrame(animateMove);
            }
        }
        animateMove();
    }

    function resetCamera() {
        if (!currentTarget) return;
        currentTarget = null;
        controls.enableRotate = true;
        let progress = 0;
        function animateReset() {
            if (progress < 1) {
                progress += 0.02;
                camera.position.lerp(previousCameraPosition, progress);
                controls.target.lerp(new THREE.Vector3(0, 0, 0), progress);
                requestAnimationFrame(animateReset);
            }
        }
        animateReset();
    }

    function onTap(x, y) {
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(planes);
        if (intersects.length > 0) {
            moveToPlane(intersects[0].object);
        } else {
            resetCamera();
        }
    }

    let lastTap = 0;
    function onTouchStart(event) {
        if (event.touches.length === 1) {
            let now = Date.now();
            if (now - lastTap < 300) {
                resetCamera();
            } else {
                onTap(event.touches[0].clientX, event.touches[0].clientY);
            }
            lastTap = now;
        }
    }

    function onTouchMove(event) {
        if (event.touches.length === 1) {
            controls.handleTouchMoveRotate(event);
        }
    }

    renderer.domElement.addEventListener('click', (event) => onTap(event.clientX, event.clientY));
    renderer.domElement.addEventListener('touchstart', onTouchStart);
    renderer.domElement.addEventListener('touchmove', onTouchMove);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
