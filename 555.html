<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game with React</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.20.12/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;
    const { createRoot } = ReactDOM;

    const App = () => {
      const [userData, setUserData] = useState(null);
      const [score, setScore] = useState(30);
      const [clickCount, setClickCount] = useState(0);
      const [winCount, setWinCount] = useState(0);
      const [lossCount, setLossCount] = useState(0);
      const [level, setLevel] = useState(1);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);

      const cells = Array.from(document.querySelectorAll('.cell'));
      const scoreElement = document.getElementById('score');
      const clickCountElement = document.getElementById('clickCount');
      const winCountElement = document.getElementById('winCount');
      const lossCountElement = document.getElementById('lossCount');
      const playButton = document.getElementById('playButton');
      const restartButton = document.getElementById('restartButton');

      const messages = {
        horizontal: document.getElementById('horizontalMessage'),
        vertical: document.getElementById('verticalMessage'),
        diagonal: document.getElementById('diagonalMessage'),
        total: document.getElementById('totalPointsMessage'),
        end: document.getElementById('endMessage')
      };

      const getUserIdFromUrl = () => {
        const params = new URLSearchParams(window.location.search);
        return params.get('user_id');
      };

      const fetchUserData = async (userId) => {
        setLoading(true);
        setError(null);

        try {
          const response = await fetch(`https://dbf3-213-109-225-82.ngrok-free.app/get_user?user_id=${userId}`, {
            headers: { 'ngrok-skip-browser-warning': 'true' },
          });

          if (!response.ok) throw new Error(`Ошибка ${response.status}: ${response.statusText}`);

          const user = await response.json();
          setUserData(user);
          setScore(user.points);
          setLevel(user.level || 1);
        } catch (err) {
          setError(err.message || 'Ошибка загрузки данных.');
        } finally {
          setLoading(false);
        }
      };

      const updateServer = async () => {
        if (!userData) return;

        try {
          await fetch('https://dbf3-213-109-225-82.ngrok-free.app/edit_points', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
            body: JSON.stringify({ user_id: userData.id, points: score }),
          });

          await fetch('https://dbf3-213-109-225-82.ngrok-free.app/edit_level', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
            body: JSON.stringify({ user_id: userData.id, level }),
          });

          alert('Данные успешно обновлены!');
        } catch (err) {
          alert('Ошибка при обновлении данных: ' + err.message);
        }
      };

      useEffect(() => {
        const userId = getUserIdFromUrl();
        if (userId) fetchUserData(userId);
        else setError('Пользователь не идентифицирован. Проверьте ссылку.');
      }, []);

      useEffect(() => {
        if (userData) updateServer();
      }, [score, level]);

      // Логика игры
      const flashCells = (cellsToFlash, colorClass, delay = 0) => {
        return new Promise((resolve) => {
          setTimeout(() => {
            cellsToFlash.forEach(cell => cell.classList.add(colorClass));
          }, delay);

          setTimeout(() => {
            cellsToFlash.forEach(cell => cell.classList.remove(colorClass));
            resolve(); // Завершение подсветки
          }, delay + 300); // Подсветка длится 500 мс
        });
      };

      const checkHorizontal = async () => {
        let points = 0;
        let matchInfo = [];
        for (let i = 0; i < 9; i += 3) {
          const row = [cells[i], cells[i + 1], cells[i + 2]];
          const values = row.map(cell => cell.textContent);
          const counts = {};

          values.forEach(value => {
            counts[value] = (counts[value] || 0) + 1;
          });

          if (Object.values(counts).includes(3)) {
            points += 5;
            await flashCells(row, 'highlight-green');
            matchInfo.push("+5");
          } else if (Object.values(counts).includes(2)) {
            points += 3;
            await flashCells(row.filter(cell => counts[cell.textContent] === 2), 'highlight-green');
            matchInfo.push("+3");
          } else {
            matchInfo.push("0");
          }
        }

        document.getElementById('horizontalResult').textContent = matchInfo.join(", ");
        return points;
      };

      const checkVertical = async () => {
        let points = 0;
        let matchInfo = [];
        for (let i = 0; i < 3; i++) {
          const column = [cells[i], cells[i + 3], cells[i + 6]];
          const values = column.map(cell => cell.textContent);
          const counts = {};

          values.forEach(value => {
            counts[value] = (counts[value] || 0) + 1;
          });

          if (Object.values(counts).includes(3)) {
            points += 5;
            await flashCells(column, 'highlight-blue', 300);
            matchInfo.push("+5");
          } else if (Object.values(counts).includes(2)) {
            points += 3;
            await flashCells(column.filter(cell => counts[cell.textContent] === 2), 'highlight-blue', 300);
            matchInfo.push("+3");
          } else {
            matchInfo.push("0");
          }
        }

        document.getElementById('verticalResult').textContent = matchInfo.join(", ");
        return points;
      };

      const checkDiagonal = async () => {
        let points = 0;
        const mainDiagonal = [cells[0], cells[4], cells[8]];
        const antiDiagonal = [cells[2], cells[4], cells[6]];
        const diagonals = [mainDiagonal, antiDiagonal];
        let matchInfo = [];

        for (const diagonal of diagonals) {
          const values = diagonal.map(cell => cell.textContent);
          const counts = {};

          values.forEach(value => {
            counts[value] = (counts[value] || 0) + 1;
          });

          if (Object.values(counts).includes(3)) {
            points += 6;
            await flashCells(diagonal, 'highlight-yellow', 300);
            matchInfo.push("+6");
          } else if (Object.values(counts).includes(2)) {
            points += 4;
            await flashCells(diagonal.filter(cell => counts[cell.textContent] === 2), 'highlight-yellow', 300);
            matchInfo.push("+4");
          } else {
            matchInfo.push("0");
          }
        }

        document.getElementById('diagonalResult').textContent = matchInfo.join(", ");
        return points;
      };

      const playGame = async () => {
        playButton.disabled = true; // Блокируем кнопку на время выполнения хода

        cells.forEach(cell => cell.textContent = Math.floor(Math.random() * 10));
        setClickCount(prev => prev + 1);
        clickCountElement.textContent = clickCount;

        const horizontalPoints = await checkHorizontal();
        const verticalPoints = await checkVertical();
        const diagonalPoints = await checkDiagonal();

        const totalPoints = horizontalPoints + verticalPoints + diagonalPoints;

        if (totalPoints > 0) {
          document.getElementById('totalResult').textContent = totalPoints;
          setScore(prev => prev + totalPoints);
        } else {
          document.getElementById('totalResult').textContent = "-8 (нет совпадений)";
          setScore(prev => prev - 8);
        }

        // Проверяем состояние игры
        if (score >= 200) {
          setWinCount(prev => prev + 1);
          winCountElement.textContent = winCount;
          messages.end.textContent = "Вы выиграли!";
          playButton.disabled = true;
          restartButton.style.display = 'block';
          updateServer();
        } else if (clickCount >= 22) {
          if (score < 200) {
            setLossCount(prev => prev + 1);
            lossCountElement.textContent = lossCount;
            messages.end.textContent = "Вы проиграли! Не хватило очков.";
          } else {
            setWinCount(prev => prev + 1);
            winCountElement.textContent = winCount;
            messages.end.textContent = "Вы выиграли! Набрано 200 очков.";
          }
          playButton.disabled = true;
          restartButton.style.display = 'block';
          updateServer();
        } else {
          playButton.disabled = false;
        }
      };

      return (
        <div className="App">
          <header className="App-header">
            <h1>Добро пожаловать!</h1>
            <p>ID: {userData?.id}</p>
            <p>Имя пользователя: {userData?.username}</p>
            <p>Очки: {score}</p>
            <p>Уровень: {level}</p>
            <button onClick={playGame}>Играть</button>
            <button onClick={() => setScore(30)}>Сбросить игру</button>
            <p>Кол-во побед: {winCount}</p>
            <p>Кол-во поражений: {lossCount}</p>
            <div id="horizontalMessage"></div>
            <div id="verticalMessage"></div>
            <div id="diagonalMessage"></div>
            <div id="totalPointsMessage"></div>
            <div id="endMessage"></div>
            <button id="restartButton" style={{ display: 'none' }} onClick={() => window.location.reload()}>
              Перезапустить
            </button>
          </header>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
